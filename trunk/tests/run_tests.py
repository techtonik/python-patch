"""
TestSuite

Files/directories that comprise one test all have the same name, but a different extensions:
*.patch
*.from
*.to

*.doctest   - self contained doctest patch

TODO: recheck input/output sources

"""

import os
import sys
import re
import shutil
import unittest
import copy
from os import listdir
from os.path import abspath, dirname, exists, join, isdir
from tempfile import mkdtemp



#: full path for directory with tests
tests_dir = dirname(abspath(__file__))


# import patch.py from parent directory
save_path = sys.path
sys.path.insert(0, dirname(tests_dir))
import patch
sys.path = save_path


# ----------------------------------------------------------------------------
class TestPatches(unittest.TestCase):
  """
  Note a unittest hack:

  test* methods in this class are generated by add_test_methods() function
  below using information about *.patch files from tests directory

  """
  def _assert_files_equal(self, file1, file2):
      f1 = f2 = None
      try:
        f1 = open(file1, "rb")
        f2 = open(file2, "rb")
        for line in f1:
          self.assertEqual(line, f2.readline())

      finally:
        if f2:
          f2.close()
        if f1:
          f1.close()
  
  def _assert_dirs_equal(self, dir1, dir2):
      # recursion here
      for e in listdir(dir1):
        if e == ".svn":
          continue
        e1path = join(dir1, e)
        e2path = join(dir2, e)
        self.assert_(exists(e1path))
        self.assert_(exists(e2path), "%s doesn't exist" % e2path)
        self.assert_(isdir(e1path) == isdir(e2path))
        if not isdir(e1path):
          self._assert_files_equal(e1path, e2path)
        else:
          self._assert_dirs_equal(e1path, e2path)
  
  def _run_test(self, testname):
      """
      boilerplate for running *.patch file tests
      """

      # 1. create temp test directory
      # 2. copy files
      # 3. execute file-based patch 
      # 4. compare results
      # 5. cleanup on success

      tmpdir = mkdtemp(prefix="%s."%testname)

      patch_file = join(tmpdir, "%s.patch" % testname)
      shutil.copy(join(tests_dir, "%s.patch" % testname), patch_file)
      
      from_src = join(tests_dir, "%s.from" % testname)
      from_tgt = join(tmpdir, "%s.from" % testname)

      if not isdir(from_src):
        shutil.copy(from_src, from_tgt)
      else:
        for e in listdir(from_src):
          if e == ".svn":
            continue
          epath = join(from_src, e)
          if not isdir(epath):
            shutil.copy(epath, join(tmpdir, e))
          else:
            shutil.copytree(epath, join(tmpdir, e))


      # 3.
      # test utility as a whole
      patch_tool = join(dirname(tests_dir), "patch.py")
      save_cwd = os.getcwdu()
      os.chdir(tmpdir)
      ret = os.system("%s %s %s" % (sys.executable, patch_tool, patch_file))
      assert ret == 0, "Error %d running test %s" % (ret, testname)
      os.chdir(save_cwd)


      # 4.
      # compare results
      if not isdir(from_src):
        self._assert_files_equal(join(tests_dir, "%s.to" % testname), from_tgt)
      else:
        # need recursive compare
        self._assert_dirs_equal(join(tests_dir, "%s.to" % testname), tmpdir)

        

      shutil.rmtree(tmpdir)
      return 0


def add_test_methods(cls):
    """
    hack to generate test* methods in target class - one
    for each *.patch file in tests directory
    """

    # list testcases - every test starts with number
    # and add them as test* methods
    testptn = re.compile(r"^(?P<name>\d{2,}.+)\.(?P<ext>[^\.]+)")
    testset = sorted( set([testptn.match(e).group('name') for e in listdir(tests_dir) if testptn.match(e)]) )

    for testname in testset:
      setattr(cls, "test%s" % testname, lambda self, name=testname: self._run_test(name))

add_test_methods(TestPatches)

# ----------------------------------------------------------------------------


if __name__ == '__main__':
    unittest.main()
