#labels Phase-Design,Featured
== History ==

The project started because Windows platform lacks native tool to apply
patches, and there was no pure python cross-platform solution that could
be safely run by web server process.

Usually patches are applied with a UNIX *patch* utility available as
[http://www.gnu.org/software/patch/ a part of] GNU tools. It is
[http://gnuwin32.sourceforge.net/packages/patch.htm ported to windows],
but still seems
[http://www.google.com/search?q=Assertion+failed%3A+hunk%2C+file+patch.c rather buggy],
insecure for web server process and not customizable without a C compiler.
And it is a good idea to have a *diff.py* counterpart
[http://bugs.python.org/issue2057 bundled] with Python.

*patch.py* is meant to be semi-automatic tool with intuitive defaults,
that also takes care of line end differences automatically.


== Status ==

*NOTE:* API is unstable, so use strict dependencies on major version when
using this tool as a library.

It is understands _unified diffs_ only. Currently it doesn't support file
renames, creation and removals.

*patch.py* is designed to transparently handle line end differences. Line
endings from patch are converted into 
best suitable format for patched file. patch.py scans line endings in source
file, and if they are consistent - lines from patch are applied with the
same ending. If linefeed in source are inconsistend - lines from patch are
applied "as is".


Parsing of diff is done in a in very straightforward manner as an exercise
to approach the problem of parsing on my own before learning the 'proper
ways'. Thanks creators, _the format of unified diff_ is rather simple (an
illustration of Subversion style unified diff is included in
[http://python-patch.googlecode.com/svn/trunk/doc/ source doc/] directory).

It would be nice to further simplify parser, make it more modular to allow easy
customization and extension, but the primary focus for now is to figure out
an API that will make it usable as a library. There is separate TODO item to
check behavior of "\ No newline at end of file" cases. Other goals is to
expand test coverage, and try to make script more interactive.


== Library usage ==
[http://code.google.com/p/rainforce/wiki/WartsOfPython#Logging_(2.x_tested,_3.x_unknown) Unfortunately], you'll have to configure `logging` module for "patch" module (or root logger of your application) to avoid message 'No handlers could be found for logger "patch"'. For example, root logger for application can be configured using:

{{{
import logging
logging.basicConfig()
}}}


== Changes ==
{{{
1.xx.xx - Major API Break
   - added normalization to filenames to protect against patching files
     using absolute paths or files in parent directories
   - added detection of SVN, GIT and HG patch types, unrecognized patches
     are marked PLAIN
   - API changes
     * previous Patch is renamed to PatchSet
     * Patch.header is now a list of strings
     + PatchSet.type and Patch.type
     * PatchSet.parse() now returns True if parsing completed without errors
     + PatchSet.__len__()
11.01
   - patch.py can read patches from web
   - patch.py returns -1 if there were errors during patching
   - store patch headers (necessary for future DIFF/SVN/HG/GIT detection)
   - report about extra bytes at the end after patch is parsed
   - API changes
     + fromurl()
     * Patch.apply() now returns True on success
10.11
   - fixed fromstring() failure due to invalid StringIO import (issue #9)
     (thanks john.stumpo for reporting)
   - added --verbose and --quiet options
   - improved message logging
   - change "successfully patched..." message to INFO instead of WARN
     (thanks Alex Stewart for reporting and patch)
   - skip __main__ imports when used as a library (patch by Alex Stewart)
   - API changes
      * renamed class HunkInfo to Hunk
      + Patch.type placeholder (no detection yet - parser is not ready)
      + constants for patch types DIFF/PLAIN, HG/MERCURIAL, SVN/SUBVERSION
      + Patch.header for saving headers which can be used later to extract
        additional meta information such as commit message
   - internal: improving parser speed by allowing blocks fetch lines on
               demand
   - test suite improvements
10.04
    - renamed debug option to --debug
    - API changes
      * method names are now underscored for consistency with difflib
      + addded Patch.can_patch(filename) to test if source file is in list
        of source filenames and can be patched
      * use designated logger "python_patch" instead of default
9.08-2
    - compatibility fix for Python 2.4
9.08-1
    - fixed issue #2 - remove trailing whitespaces from filename
      (thanks James from Twisted Fish)
    - API changes
      + added Patch and HunkInfo classes
      * moved utility methods into Patch
      + build Patch object by specifying stream to constructor
        or use top level functions fromfile() and fromstring()
    - added test suite
8.06-2
    - compatibility fix for Python 2.4
8.06-1
    - initial release
}}}


== Future ==

Patch utility in Python makes it possible to implement online "submit,
review and apply" module. Similar to [http://www.reviewboard.org/ Review Board]
for code, but suitable for all kind of textual content that uses
unified diffs as an interchange format between users, website, and version
control system. With this system patches can be applied after on site
review, automatically storing the names of patch contributors in SVN
history logs without requiring write access for these contributors. This
system is not the scope of this project though.

Additional unified diff parsers may be added in future to compare different
parsing techniques (with [http://pyparsing.wikispaces.com/ pyparsing],
[http://www.ibm.com/developerworks/library/l-spark.html SPARK] or
[http://www.google.com/Top/Computers/Programming/Languages/Python/Modules/Text_Processing/ others]
as example).

See also https://code.google.com/p/rainforce/wiki/ModerationQueue